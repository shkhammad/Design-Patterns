# Design Patterns
Design Patterns are divided into three categories:

 1.   **Creational**: The design patterns that deal with the creation of an object.
 2.   **Structural**: The design patterns in this category deals with the class structure such as Inheritance and Composition.
 3. **Behavioral**: This type of design patterns provide solution for the better interaction between objects, how to provide lose coupling, and flexibility to extend easily in future.

**Tip:** Usecase of each pattern is described in brief in every **application** class.
 
 ## Creational Design Patterns
 
| Name | Description  |
|-|-|
| Singleton | The singleton pattern restricts the initialization of a class to ensure that only one instance of the class can be created |
| Factory Method| The factory method pattern takes out the responsibility of instantiating a object from the class to a factory class|
| Abstract Factory | Allows us to create a Factory for factory classes|
| Builder | Creating an object step by step and a method to finally get the object instance|

 ## Structural Design Patterns
 
| Name | Description |
|-|-|
| Adapter | Provides an interface between two unrelated entities so that they can work together |
| Composite | Used when we have to implement a part-whole hierarchy. For example, a diagram made of other pieces such as circle, square, triangle, etc. |
| Proxy | Provides a placeholder for another object to control access to it |
| Facade | Creating a wrapper interfaces on top of existing interfaces to help client applications |
| Decorator | The decorator design pattern is used to modify the functionality of an object at runtime |

 ## Behavioral Design Patterns
 
| Name | Description |
|-|-|
| Template Method | Used to create a template method stub and defer (pass) some of the steps of implementation to the subclasses |
| Mediator | Used to provide a centralized communication medium between different objects in a system |
| Observer | Useful when you are interested in the state of an object and want to get notified whenever there is any change |
| Strategy | Strategy pattern is used when we have multiple algorithm for a specific task and client decides the actual implementation to be used at runtime |
| Command | Command Pattern is used to implement loose coupling in a request-response model |
| State | State design pattern is used when an object changes it’s behavior based on it’s internal state |
| Iterator | Used to provide a standard way to traverse through a group of objects |
	
